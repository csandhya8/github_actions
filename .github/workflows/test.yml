name: Deploy

on:
  workflow_dispatch:
    inputs:
      lob:
        type: choice
        description: Target lob
        required: true
        options:
          - CM_CodeDepot
          - CM_OPT
          - CM_UHC

      targetlob:
        type: choice
        description: Target LOB to deploy
        required: true
        options:
          - CMRegressionTestApp
          - CMOPTAccountTypeCallReason
          - CMOPTITSS

      rule_package_name:
        type: choice
        description: Rule package name
        required: true
        options:
          - cmoptaccounttypecallreason.inbound.rt
          - cmoptitss.inbound.rt
          - cmoptrxspecialitycampaignname.inbound.rt
          - cmoptrxspecialityclientname.inbound.rt
          - cmoptrxspecialitytherapycode.inbound.rt
          - cmregressiontestapp.inbound.rt
          - cmuhccallerintent.inbound.rt
          - cmuhccrosschannel.inbound.rt
          - cmuhccseligibility.inbound.rt
          - cmuhccsrouting.inbound.rt
          - cmuhcdental.inbound.rt
          - cmuhceiclaimsdenial.inbound.rt
          - cmuhceifastpass.inbound.rt
          - cmuhceiprime.inbound.rt
          - cmuhceirouting.inbound.rt
          - cmuhceispecialtyivr.inbound.rt
          - cmuhcmrproviderrestriction.inbound.rt
          - cmuhcmrrouting.inbound.rt
          - cmuhcpacrouting.inbound.rt
          - cmuhcrepeatcaller.inbound.rt
          - cmuhcvision.inbound.rt
          - cmoptaccounttypecallreason.inbound.rt.hotfix
          - cmoptitss.inbound.rt.hotfix
          - cmoptrxspecialitycampaignname.inbound.rt.hotfix
          - cmoptrxspecialityclientname.inbound.rt.hotfix
          - cmoptrxspecialitytherapycode.inbound.rt.hotfix
          - cmregressiontestapp.inbound.rt.hotfix
          - cmuhccallerintent.inbound.rt.hotfix
          - cmuhccrosschannel.inbound.rt.hotfix
          - cmuhccseligibility.inbound.rt.hotfix
          - cmuhccsrouting.inbound.rt.hotfix
          - cmuhcdental.inbound.rt.hotfix
          - cmuhceiclaimsdenial.inbound.rt.hotfix
          - cmuhceifastpass.inbound.rt.hotfix
          - cmuhceiprime.inbound.rt.hotfix
          - cmuhceirouting.inbound.rt.hotfix
          - cmuhceispecialtyivr.inbound.rt.hotfix
          - cmuhcmrproviderrestriction.inbound.rt.hotfix
          - cmuhcmrrouting.inbound.rt.hotfix
          - cmuhcpacrouting.inbound.rt.hotfix
          - cmuhcrepeatcaller.inbound.rt.hotfix
          - cmuhcvision.inbound.rt.hotfix

jobs:
  validate-inputs:
    runs-on: ubuntu-latest
    outputs:
      ok: ${{ steps.validate.outputs.ok }}
      normalized_version: ${{ steps.normalize.outputs.normalized_version }}
    steps:
      - name: Validate lob/targetlob compatibility
        id: validate
        shell: bash
        run: |
          set -euo pipefail
          lob="${{ github.event.inputs.lob }}"
          svc="${{ github.event.inputs.targetlob }}"

          # Allowed mapping:
          declare -A allowed
          allowed[CM_CodeDepot]="CMRegressionTestApp"
          allowed[CM_OPT]="CMOPTAccountTypeCallReason,CMOPTITSS,CMOPTRxSpecialityCampaignName,CMOPTRxSpecialityClientName,CMOPTRxSpecialityTherapyCode"
          allowed[CM_UHC]="CMUHCCSEligibility,CMUHCCSRouting,CMUHCCallerIntent,CMUHCCrossChannel,CMUHCDental,CMUHCEIClaimsDenial,CMUHCEIFastPass,CMUHCEIPrime,CMUHCEIRouting,CMUHCEISpecialtyIVR,CMUHCMRProviderRestriction,CMUHCMRRouting,CMUHCPACRouting,CMUHCRepeatCaller,CMUHCVision"

          if [[ -z "${allowed[$lob]:-}" ]]; then
            echo "::error::Unknown lob '$lob'"
            echo "ok=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          IFS=',' read -r -a arr <<< "${allowed[$lob]}"
          ok="false"
          for x in "${arr[@]}"; do
            [[ "$x" == "$svc" ]] && ok="true" && break
          done

          if [[ "$ok" != "true" ]]; then
            echo "::error::targetlob '$svc' is not allowed for lob '$lob'. Allowed for '$lob': ${allowed[$lob]}"
            echo "ok=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          echo "ok=true" >> "$GITHUB_OUTPUT"

  deploy:
    needs: [validate-inputs]
    if: needs.validate-inputs.outputs.ok == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Summary
        run: |
          echo "lob: ${{ github.event.inputs.lob }}"
          echo "targetlob: ${{ github.event.inputs.targetlob }}"
          echo "rule_package_name: ${{ github.event.inputs.rule_package_name }}"

      - name: Fetch releases from Artifactory
        id: fetch
        env:
          RULE_PACKAGE_NAME: ${{ inputs.rule_package_name }}
          TARGET_LOB: ${{ inputs.target_lob }}
          ARTIFACTORY_URL: https://trial7091u2.jfrog.io/artifactory/test/demos/19939878363/demo.zip
        run: |
          set -euo pipefail
          # ---- Derive rule type & normalized underscore package name ----
underscorePackageName="${RULE_PACKAGE_NAME//./_}"
rulePackageType=""
if [[ "${RULE_PACKAGE_NAME}" == *.hotfix ]]; then
  rulePackageType="HotFix"
  # Trim trailing _hotfix for path derivation if needed
  underscorePackageName="${underscorePackageName%_hotfix}"
elif [[ "${RULE_PACKAGE_NAME}" == *.rt ]]; then
  rulePackageType="Normal"
else
  echo "ERROR: RULE_PACKAGE_NAME must end with .rt or .hotfix" >&2
  exit 2
fi

# ---- Call Artifactory with JFrog Access Token (Bearer) ----
if [[ -z "${JFROG_ACCESS_TOKEN:-}" ]]; then
  echo "ERROR: Missing JFROG_ACCESS_TOKEN secret" >&2
  exit 3
fi

# Save response and HTTP code
http_code=$(curl -sS -L \
  -H "Authorization: Bearer ${JFROG_ACCESS_TOKEN}" \
  -o response.json \
  -w "%{http_code}" \
  "${artifactoryURL}")

# Check HTTP status
if [[ "${http_code}" -lt 200 || "${http_code}" -ge 300 ]]; then
  echo "ERROR: Artifactory request failed with HTTP ${http_code}" >&2
  echo "Response body:" >&2
  cat response.json >&2 || true
  exit 4
fi

# ---- Parse response: expect JSON with `files` array of paths ----
# Example expected shape:
# {
#   "files": [
#     "some/path/package_1.2.3.zip",
#     "some/path/package_1.2.4_hotfix.zip"
#   ]
# }
mapfile -t all_paths < <(jq -r '.files[]?' response.json)

declare -a non_hotfix=()
declare -a hotfix=()

for p in "${all_paths[@]}"; do
  fname="${p##*/}"        # last path segment
  base="${fname%.zip}"    # strip .zip
  if [[ "${rulePackageType}" == "Normal" ]]; then
    [[ "${base}" == *"_hotfix"* ]] && continue
    non_hotfix+=("${base}")
  else
    [[ "${base}" == *"_hotfix"* ]] || continue
    hotfix+=("${base}")
  fi
done

# ---- Natural sort & limits (20 normal, 10 hotfix) ----
sort_desc_take () {
  local n="$1"; shift
  if [[ "$#" -eq 0 ]]; then return 0; fi
  # sort -V sorts natural version strings, tac reverses for descending
  printf '%s\n' "$@" | sort -V | tac | head -n "${n}"
}

latest_non_hotfix="$(sort_desc_take 20 "${non_hotfix[@]:-}")"
latest_hotfix="$(sort_desc_take 10 "${hotfix[@]:-}")"

# Combine non-hotfix + hotfix results; remove empty lines
combined="$(printf '%s\n%s\n' "${latest_non_hotfix}" "${latest_hotfix}" | awk 'NF')"
release_list="$(printf '%s\n' "${combined}" | paste -sd ',' -)"

rule_release_found="NO"
[[ -n "${combined}" ]] && rule_release_found="YES"

# ---- Plain echo outputs (no HTML) ----
echo "------------------------------------------------------------"
echo "Rule releases for RULE_PACKAGE_NAME='${RULE_PACKAGE_NAME}'"
[[ -n "${keyEnv:-}" ]] && echo "Environment: ${keyEnv}"
echo "Rule package type: ${rulePackageType}"
echo "HTTP status from Artifactory: ${http_code}"
echo "------------------------------------------------------------"
echo "rule_release_found=${rule_release_found}"
echo "release_list=${release_list}"
echo "------------------------------------------------------------"
if [[ -n "${release_list}" ]]; then
  echo "Releases (one per line):"
  printf '%s\n' "${combined}"
else
  echo "No matching releases found."
fi
echo "------------------------------------------------------------"

# ---- Optionally expose outputs for downstream GitHub Actions steps ----
if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
  {
    echo "release_list=${release_list}"
    echo "rule_release_found=${rule_release_found}"
  } >> "$GITHUB_OUTPUT"
fi
